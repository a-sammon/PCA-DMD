# -*- coding: utf-8 -*-
"""SimpleDMD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QGLdGjiBVc1ttJTss2SbEa0Dxi5cZtNF
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np

!pip install pydmd
import pydmd

from pydmd import DMD

!pip install scipy
import scipy

!pip install future
import future
!pip install sphinx
import sphinx

from sklearn.decomposition import PCA

import pandas as pd

from sklearn.preprocessing import StandardScaler
from pydmd import DMDc
from numpy.testing import assert_array_almost_equal

from numpy import linalg as LA
from pydmd import CDMD

import timeit
import psutil

!pip install ipython-autotime
# %load_ext autotime

!pip install memory_profiler
from memory_profiler import memory_usage

def f1(x,t):
    return 1./np.cosh(x+3)*np.exp(2.3j*t)

def f2(x,t):
    return 2./np.cosh(x)*np.tanh(x)*np.exp(2.8j*t)

x = np.linspace(-5, 5, 128)
t = np.linspace(0, 4*np.pi, 256)

xgrid, tgrid = np.meshgrid(x, t)

X1 = f1(xgrid, tgrid)
X2 = f2(xgrid, tgrid)
X = X1 + X2

titles = ['$f_1(x,t)$', '$f_2(x,t)$', '$f$']
data = np.array([X1, X2, X])

fig = plt.figure(figsize=(17,6))
for n, title, d in zip(range(131,134), titles, data):
    plt.subplot(n)
    plt.pcolor(xgrid, tgrid, d.real)
    plt.title(title)
    plt.xlabel("x")
    plt.ylabel("t")
plt.colorbar()
plt.show()

Xr = X1.real + X2.real
Xi = X1.imag + X2.imag
Xr.shape

pca_r = PCA(n_components=2)
pca_i = PCA(n_components=2)

PCr = pca_r.fit_transform(Xr)
PCi = pca_i.fit_transform(Xi)

pci = pd.DataFrame(PCi)
pcr = pd.DataFrame(PCr)

pcf = pcr.T.append(pci.T)
PCf = np.array(pcf)

PCf.shape

pd.DataFrame(PCf)

#PC = pca.fit_transform(Xf)
eVecs = pca.components_

eVecs.shape

eigenvalues_r = pca_r.explained_variance_
explained_variance_ratio_r = pca_r.explained_variance_ratio_

eigenvalues_i = pca_i.explained_variance_
explained_variance_ratio_i = pca_i.explained_variance_ratio_

# Scree plot
num_components = len(explained_variance_ratio_r)
plt.bar(range(1, num_components + 1), explained_variance_ratio_r)
plt.xlabel('Principal Component')
plt.ylabel('Explained Variance Ratio')
plt.title('Scree Plot')
plt.show()

# Summary table
cumulative_explained_variance_ratio_r = np.cumsum(explained_variance_ratio_r)
summary_table = np.column_stack((range(1, num_components + 1), explained_variance_ratio_r, cumulative_explained_variance_ratio_r))
print('PC\tExplained Variance Ratio\tCumulative Explained Variance Ratio')
for row in summary_table:
    print('\t'.join(str(x) for x in row))

# Scree plot
num_components = len(explained_variance_ratio_i)
plt.bar(range(1, num_components + 1), explained_variance_ratio_i)
plt.xlabel('Principal Component')
plt.ylabel('Explained Variance Ratio')
plt.title('Scree Plot')
plt.show()

# Summary table
cumulative_explained_variance_ratio_i = np.cumsum(explained_variance_ratio_i)
summary_table = np.column_stack((range(1, num_components + 1), explained_variance_ratio_i, cumulative_explained_variance_ratio_i))
print('PC\tExplained Variance Ratio\tCumulative Explained Variance Ratio')
for row in summary_table:
    print('\t'.join(str(x) for x in row))

plt.plot(x, eVecs[0,:])

plt.plot(x, eVecs[1,:])

plt.plot(x, eVecs[2,:])

plt.pcolor(xgrid, tgrid, Xr)
fig = plt.colorbar()

plt.pcolor(xgrid, tgrid, Xi)
fig = plt.colorbar()

Z = PCf

# Perform DMD
pdmd = DMD(svd_rank=4)
pdmd.fit(Z)

# Access DMD modes and dynamics
pmodes = pdmd.modes.T
pdynamics = pdmd.dynamics

# Visualize DMD modes and dynamics
plt.figure(figsize=(12, 4))

# Plot DMD modes
plt.subplot(1, 2, 1)
for mode in pmodes:
    plt.plot(mode)
plt.title('DMD Modes')

# Plot DMD dynamics
plt.subplot(1, 2, 2)
for dynamic in pdynamics:
    plt.plot(dynamic)
plt.title('DMD Dynamics')

plt.tight_layout()
plt.show()

pd.DataFrame(pdynamics)

Z = X.T

# Perform DMD
dmd = DMD(svd_rank=2)
dmd.fit(Z)

# Access DMD modes and dynamics
modes = dmd.modes.T
dynamics = dmd.dynamics

# Visualize DMD modes and dynamics
plt.figure(figsize=(12, 4))

# Plot DMD modes
plt.subplot(1, 2, 1)
for mode in modes:
    plt.plot(mode)
plt.title('DMD Modes')

# Plot DMD dynamics
plt.subplot(1, 2, 2)
for dynamic in dynamics:
    plt.plot(dynamic)
plt.title('DMD Dynamics')

plt.tight_layout()
plt.show()

snapshots_matrix = PCf
random_matrix = np.random.permutation(
    snapshots_matrix.shape[0] * snapshots_matrix.shape[1]
)
random_matrix = random_matrix.reshape(
    snapshots_matrix.shape[1], snapshots_matrix.shape[0]
)

compression_matrix = random_matrix / np.linalg.norm(random_matrix)

cdmd = CDMD(svd_rank=4, compression_matrix=compression_matrix)
cdmd.fit(snapshots_matrix)

plt.figure(figsize=(16, 8))
plt.subplot(1, 2, 1)
plt.plot(cdmd.modes.real)
plt.subplot(1, 2, 2)
plt.plot(cdmd.dynamics.T.real)
plt.show()

print(X.T.shape)
print(Z.shape)

print(dmd.modes.shape)
print(dmd.dynamics.shape)

dmd.dmd_timesteps

omega = np.log(dmd.eigs)
omega

fig, ax = plt.subplots()
colors = np.linspace(0, 1, len(omega))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(omega), np.imag(omega), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
#unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
#ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='datalim')
ax.axvline(x=0, color='red', linestyle='dashed')
ax.set_xlim([-1.5, 0.5])
ax.set_ylim([-0.5, 0.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.grid(True)
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.show()

omega2 = np.log(pdmd.eigs)
omega2

filtered_eigenvalues = [eig for eig in omega2 if eig.imag > 0]
fig, ax = plt.subplots()
colors = np.linspace(0, 1, len(filtered_eigenvalues))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(filtered_eigenvalues), np.imag(filtered_eigenvalues), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
#unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
#ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='datalim')
ax.axvline(x=0, color='red', linestyle='dashed')
ax.set_xlim([-1.5, 0.5])
ax.set_ylim([-0.5, 0.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.grid(True)
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.show()

eigenvalues = pdmd.eigs
for eig in eigenvalues:
    if eig.imag > 0:  # Filter eigenvalues with positive imaginary parts
        print("Eigenvalue {}: distance from unit circle {}".format(eig, np.abs(np.sqrt(eig.imag**2 + eig.real**2) - 1)))

fig, ax = plt.subplots()
filtered_eigenvalues = [eig for eig in eigenvalues if eig.imag > 0]
colors = np.linspace(0, 1, len(filtered_eigenvalues))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(filtered_eigenvalues), np.imag(filtered_eigenvalues), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='box')
ax.set_xlim([-1.5, 1.5])
ax.set_ylim([-1.5, 1.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.grid(True)
plt.show()

eigenvalues = dmd.eigs

for eig in eigenvalues:
    print("Eigenvalue {}: distance from unit circle {}".format(eig, np.abs(np.sqrt(eig.imag**2 + eig.real**2) - 1)))
fig, ax = plt.subplots()
filtered_eigenvalues = [eig for eig in eigenvalues if eig.imag > 0]
colors = np.linspace(0, 1, len(filtered_eigenvalues))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(filtered_eigenvalues), np.imag(filtered_eigenvalues), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='box')
ax.set_xlim([-1.5, 1.5])
ax.set_ylim([-1.5, 1.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.grid(True)
plt.show()

eigenvalues = pdmd.eigs

# Calculate distance from unit circle
distances = np.abs(eigenvalues.imag**2 + eigenvalues.real**2 - 1)

# Plot eigenvalues and unit circle
plt.figure()
plt.scatter(eigenvalues.real, eigenvalues.imag, c=distances, cmap='viridis', alpha=0.6)
plt.colorbar(label='Distance from unit circle')
plt.xlabel('Real')
plt.ylabel('Imaginary')
plt.title('Eigenvalues')

# Plot unit circle
theta = np.linspace(0, 2 * np.pi, 100)
plt.plot(np.cos(theta), np.sin(theta), color='red', linestyle='--', label='Unit Circle')
plt.legend()

plt.show()

eigenvalues = dmd.eigs

# Calculate distance from unit circle
distances = np.abs(eigenvalues.imag**2 + eigenvalues.real**2 - 1)

# Plot eigenvalues and unit circle
plt.figure()
plt.scatter(eigenvalues.real, eigenvalues.imag, c=distances, cmap='viridis', alpha=0.6)
plt.colorbar(label='Distance from unit circle')
plt.xlabel('Real')
plt.ylabel('Imaginary')
plt.title('Eigenvalues')

# Plot unit circle
theta = np.linspace(0, 2 * np.pi, 100)
plt.plot(np.cos(theta), np.sin(theta), color='red', linestyle='--', label='Unit Circle')
plt.legend()

plt.show()

dmd.reconstructed_data.T.shape

pd.DataFrame(PCf).T

dmd_rec = pd.DataFrame(dmd.reconstructed_data)
dmd_rec.T

dmd_rec_real = pdmd.reconstructed_data[0:2]
dmd_rec_imag = pdmd.reconstructed_data[2:]

x_recon_real = pca_r.inverse_transform(dmd_rec_real.T)
x_recon_imag = pca_i.inverse_transform(dmd_rec_imag.T)

x_recon_real[:,0:1]

#combined_array = np.array([complex(a, b) for a, b in zip(x_recon_real, x_recon_imag)])
#combined_array = np.column_stack((x_recon_real, x_recon_imag)).view(complex)

X_recon = x_recon_real + 1j * x_recon_imag

pd.DataFrame(x_recon_imag)

X_recon.shape

plt.pcolor(xgrid, tgrid, X_recon.real)
plt.xlabel("x")
plt.ylabel("t")
fig = plt.colorbar()

plt.pcolor(xgrid, tgrid, dmd.reconstructed_data.T.real)
plt.xlabel("x")
plt.ylabel("t")
fig = plt.colorbar()

plt.pcolor(xgrid, tgrid, X.real)
plt.xlabel("x")
plt.ylabel("t")
fig = plt.colorbar()

diff_dmd = X.real - dmd.reconstructed_data.T.real

diff_pcadmd = X.real - X_recon.real

plt.pcolor(xgrid, tgrid, diff_dmd)
plt.xlabel("x")
plt.ylabel("t")
fig = plt.colorbar()

plt.pcolor(xgrid, tgrid, diff_pcadmd)
plt.xlabel("x")
plt.ylabel("t")
fig = plt.colorbar()

# Define the external variables or dependencies needed by the code block
external_variable_1 = PCf

# Code block to measure execution time and RAM requirements
code_block = """
# Access the external variables or dependencies here
print(external_variable_1)

Z = PCf

# Perform DMD
pdmd = DMD(svd_rank=4)
pdmd.fit(Z)

# Access DMD modes and dynamics
pmodes = pdmd.modes.T
pdynamics = pdmd.dynamics

# Visualize DMD modes and dynamics
plt.figure(figsize=(12, 4))

# Plot DMD modes
plt.subplot(1, 2, 1)
for mode in pmodes:
    plt.plot(mode)
plt.title('DMD Modes')

# Plot DMD dynamics
plt.subplot(1, 2, 2)
for dynamic in pdynamics:
    plt.plot(dynamic)
plt.title('DMD Dynamics')

plt.tight_layout()
plt.show()
"""

execution_times = []
memory_usage = []

# Execute the code block 10 times and measure the execution time and RAM requirements
for _ in range(100):
    process = psutil.Process()
    process_memory_before = process.memory_info().rss

    # Create a setup statement to define the local namespace with the external variables
    setup_statement = f"from __main__ import external_variable_1"

    # Measure the execution time
    execution_time = timeit.timeit(stmt=code_block, setup=setup_statement, globals=globals(), number=1)

    # Measure the memory usage
    process_memory_after = process.memory_info().rss
    memory_usage.append(process_memory_after - process_memory_before)

    # Store the execution time
    execution_times.append(execution_time)

# Calculate the average execution time and RAM usage
average_execution_time = sum(execution_times) / len(execution_times)
average_memory_usage = sum(memory_usage) / len(memory_usage)

# Print the average execution time and RAM usage
print("Average Execution Time: {:.6f} seconds".format(average_execution_time))
print("Average RAM Usage: {:.2f} bytes".format(average_memory_usage))

external_variable_1 = X.T

# Code block to measure execution time and RAM requirements
code_block = """
# Access the external variables or dependencies here
print(external_variable_1)

Z = X.T

# Perform DMD
pdmd = DMD(svd_rank=2)
pdmd.fit(Z)

# Access DMD modes and dynamics
pmodes = pdmd.modes.T
pdynamics = pdmd.dynamics

# Visualize DMD modes and dynamics
plt.figure(figsize=(12, 4))

# Plot DMD modes
plt.subplot(1, 2, 1)
for mode in pmodes:
    plt.plot(mode)
plt.title('DMD Modes')

# Plot DMD dynamics
plt.subplot(1, 2, 2)
for dynamic in pdynamics:
    plt.plot(dynamic)
plt.title('DMD Dynamics')

plt.tight_layout()
plt.show()
"""

execution_times = []
memory_usage = []

# Execute the code block 10 times and measure the execution time and RAM requirements
for _ in range(100):
    process = psutil.Process()
    process_memory_before = process.memory_info().rss

    # Create a setup statement to define the local namespace with the external variables
    setup_statement = f"from __main__ import external_variable_1"

    # Measure the execution time
    execution_time = timeit.timeit(stmt=code_block, setup=setup_statement, globals=globals(), number=1)

    # Measure the memory usage
    process_memory_after = process.memory_info().rss
    memory_usage.append(process_memory_after - process_memory_before)

    # Store the execution time
    execution_times.append(execution_time)

# Calculate the average execution time and RAM usage
average_execution_time = sum(execution_times) / len(execution_times)
average_memory_usage = sum(memory_usage) / len(memory_usage)

# Print the average execution time and RAM usage
print("Average Execution Time: {:.6f} seconds".format(average_execution_time))
print("Average RAM Usage: {:.2f} bytes".format(average_memory_usage))

import sys

X_size_bytes = sys.getsizeof(X)

# Convert bytes to megabytes
X_size_kilobytes = X_size_bytes / 1024

print(f"Array size: {X_size_kilobytes:.2f} KB")

PC_size_bytes = sys.getsizeof(PCf)

# Convert bytes to megabytes
PC_size_kilobytes = PC_size_bytes / 1024

print(f"Array size: {PC_size_kilobytes:.2f} KB")

DMD_dyn_size_bytes = sys.getsizeof(dmd.dynamics)

# Convert bytes to megabytes
DMD_dyn_size_kilobytes = DMD_dyn_size_bytes / 1024

print(f"Array size: {DMD_dyn_size_kilobytes:.2f} KB")

DMD_modes_size_bytes = sys.getsizeof(dmd.modes)

# Convert bytes to megabytes
DMD_modes_size_kilobytes = DMD_modes_size_bytes / 1024

print(f"Array size: {DMD_modes_size_kilobytes:.2f} KB")

PDMD_dyn_size_bytes = sys.getsizeof(pdmd.dynamics)

# Convert bytes to megabytes
PDMD_dyn_size_kilobytes = PDMD_dyn_size_bytes / 1024

print(f"Array size: {PDMD_dyn_size_kilobytes:.2f} KB")

pDMD_modes_size_bytes = sys.getsizeof(pdmd.modes)

# Convert bytes to megabytes
pDMD_modes_size_kilobytes = pDMD_modes_size_bytes / 1024

print(f"Array size: {pDMD_modes_size_kilobytes:.2f} KB")

recon_size_bytes = sys.getsizeof(dmd.reconstructed_data)

# Convert bytes to megabytes
recon_size_kilobytes = recon_size_bytes / 1024

print(f"Array size: {recon_size_kilobytes:.2f} KB")

PCArecon_size_bytes = sys.getsizeof(X_recon)

# Convert bytes to megabytes
PCArecon_size_kilobytes = PCArecon_size_bytes / 1024

print(f"Array size: {PCArecon_size_kilobytes:.2f} KB")
# -*- coding: utf-8 -*-
"""NextDMD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_xfUUtfYGegrkTgjSr9Sig75dPzYBQti
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np

!pip install pydmd
import pydmd

from pydmd import DMD

!pip install scipy
import scipy

!pip install future
import future
!pip install sphinx
import sphinx

from sklearn.decomposition import PCA

import pandas as pd

from sklearn.preprocessing import StandardScaler
from pydmd import DMDc
from numpy.testing import assert_array_almost_equal

import time
from pydmd import CDMD

import timeit
import psutil

!pip install ipython-autotime
# %load_ext autotime

!pip install memory_profiler
from memory_profiler import memory_usage

def create_dataset(x_dim, t_dim):
    def f1(x, t):
        return np.exp(-(x**2) * 0.2) * np.cos(4 * x) * np.exp(2.3j * t)

    def f2(x, t):
        return (1 - np.exp(1 - x**2 / 6)) * np.exp(1.3j * t)

    def f3(x, t):
        return (-0.02 * x**2 + 1) * (1.1j ** (-2 * t))

    x = np.linspace(-5, 5, x_dim)
    t = np.linspace(0, 4 * np.pi, t_dim)

    xgrid, tgrid = np.meshgrid(x, t)

    X1 = f1(xgrid, tgrid)
    X2 = f2(xgrid, tgrid)
    X3 = f3(xgrid, tgrid)
    return xgrid, tgrid, (X1 + X2 + X3)

xgrid, tgrid, X = create_dataset(256, 128)
plt.figure(figsize=(7, 7))
plt.pcolor(xgrid, tgrid, X.real)
plt.xlabel("x")
plt.ylabel("t")
plt.show()

Xr = X.real
Xi = X.imag
Xr.shape

pca_r = PCA(n_components=3)
pca_i = PCA(n_components=3)

#PC = pca.fit_transform(X.real)
#eVecs = pca.components_

PCr = pca_r.fit_transform(Xr)
PCi = pca_i.fit_transform(Xi)
pci = pd.DataFrame(PCi)
pcr = pd.DataFrame(PCr)
pcf = pcr.T.append(pci.T)
PCf = np.array(pcf)

PCf.shape

eigenvalues_r = pca_r.explained_variance_
explained_variance_ratio_r = pca_r.explained_variance_ratio_

# Scree plot
num_components = len(explained_variance_ratio_r)
plt.bar(range(1, num_components + 1), explained_variance_ratio_r)
plt.xlabel('Principal Component')
plt.ylabel('Explained Variance Ratio')
plt.title('Scree Plot')
plt.show()

# Summary table
cumulative_explained_variance_ratio_r = np.cumsum(explained_variance_ratio_r)
summary_table = np.column_stack((range(1, num_components + 1), explained_variance_ratio_r, cumulative_explained_variance_ratio_r))
print('PC\tExplained Variance Ratio\tCumulative Explained Variance Ratio')
for row in summary_table:
    print('\t'.join(str(x) for x in row))

eigenvalues_i = pca_i.explained_variance_
explained_variance_ratio_i = pca_i.explained_variance_ratio_

# Scree plot
num_components = len(explained_variance_ratio_i)
plt.bar(range(1, num_components + 1), explained_variance_ratio_i)
plt.xlabel('Principal Component')
plt.ylabel('Explained Variance Ratio')
plt.title('Scree Plot')
plt.show()

# Summary table
cumulative_explained_variance_ratio_i = np.cumsum(explained_variance_ratio_i)
summary_table = np.column_stack((range(1, num_components + 1), explained_variance_ratio_i, cumulative_explained_variance_ratio_i))
print('PC\tExplained Variance Ratio\tCumulative Explained Variance Ratio')
for row in summary_table:
    print('\t'.join(str(x) for x in row))

Z = X.T

# Perform DMD
dmdo = DMD(svd_rank=3)
dmdo.fit(Z)

# Access DMD modes and dynamics
omodes = dmdo.modes.T
odynamics = dmdo.dynamics

# Visualize DMD modes and dynamics
plt.figure(figsize=(12, 4))

# Plot DMD modes
plt.subplot(1, 2, 1)
for mode in omodes:
    plt.plot(mode)
plt.title('DMD Modes')

# Plot DMD dynamics
plt.subplot(1, 2, 2)
for dynamic in odynamics:
    plt.plot(dynamic)
plt.title('DMD Dynamics')

plt.tight_layout()
plt.show()

snapshots_matrix_2 = X.T
random_matrix = np.random.permutation(
    snapshots_matrix_2.shape[0] * snapshots_matrix_2.shape[1]
)
random_matrix = random_matrix.reshape(
    snapshots_matrix_2.shape[1], snapshots_matrix_2.shape[0]
)

compression_matrix_2 = random_matrix / np.linalg.norm(random_matrix)

cdmd_2 = CDMD(svd_rank=3, compression_matrix=compression_matrix_2)
cdmd_2.fit(snapshots_matrix_2)

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(cdmd_2.modes.real)
plt.subplot(1, 2, 2)
plt.plot(cdmd_2.dynamics.T.real)
plt.show()

compression_matrix_2.shape

X.shape

Z = PCf

# Perform DMD
pdmd = DMD(svd_rank=6)
pdmd.fit(Z)

# Access DMD modes and dynamics
pmodes = pdmd.modes.T
pdynamics = pdmd.dynamics

# Visualize DMD modes and dynamics
plt.figure(figsize=(12, 4))

# Plot DMD modes
plt.subplot(1, 2, 1)
for mode in pmodes:
    plt.plot(mode)
plt.title('DMD Modes')

# Plot DMD dynamics
plt.subplot(1, 2, 2)
for dynamic in pdynamics:
    plt.plot(dynamic)
plt.title('DMD Dynamics')

plt.tight_layout()
plt.show()

snapshots_matrix = PCf
random_matrix = np.random.permutation(
    snapshots_matrix.shape[0] * snapshots_matrix.shape[1]
)
random_matrix = random_matrix.reshape(
    snapshots_matrix.shape[1], snapshots_matrix.shape[0]
)

compression_matrix = random_matrix / np.linalg.norm(random_matrix)

print(PCf.shape)
print(snapshots_matrix.shape)
print(compression_matrix.shape)

cdmd = CDMD(svd_rank=6, compression_matrix=compression_matrix)
cdmd.fit(snapshots_matrix)

plt.figure(figsize=(16, 8))
plt.subplot(1, 2, 1)
plt.plot(cdmd.modes.real)
plt.subplot(1, 2, 2)
plt.plot(cdmd.dynamics.T.real)
plt.show()

for dynamic in cdmd.dynamics:
    plt.plot(dynamic)
plt.xlim(0, 128)
plt.ylim(-10, 10)
plt.title('DMD Dynamics')

eigenvalues = cdmd.eigs

for eig in eigenvalues:
    print("Eigenvalue {}: distance from unit circle {}".format(eig, np.abs(np.sqrt(eig.imag**2 + eig.real**2) - 1)))
fig, ax = plt.subplots()
filtered_eigenvalues = [eig for eig in eigenvalues if eig.imag > 0]
colors = np.linspace(0, 1, len(filtered_eigenvalues))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(filtered_eigenvalues), np.imag(filtered_eigenvalues), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='box')
ax.set_xlim([-1.5, 1.5])
ax.set_ylim([-1.5, 1.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.grid(True)
plt.show()

omega = np.log(dmdo.eigs)
omega2 = np.log(pdmd.eigs)
omega3 = np.log(cdmd_2.eigs)

fig, ax = plt.subplots()
colors = np.linspace(0, 1, len(omega))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(omega), np.imag(omega), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
#unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
#ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='datalim')
ax.axvline(x=0, color='red', linestyle='dashed')
ax.set_xlim([-1.5, 0.5])
ax.set_ylim([-0.5, 0.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.grid(True)
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.show()

eigenvalues = [omega2[0], omega2[4], omega2[3]]

#filtered_eigenvalues = [eig for eig in omega2 if eig not in eigenvalues_to_remove]
filtered_eigenvalues = [eig for eig in eigenvalues]

fig, ax = plt.subplots()
colors = np.linspace(0, 1, len(filtered_eigenvalues))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(filtered_eigenvalues), np.imag(filtered_eigenvalues), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
#unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
#ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='datalim')
ax.axvline(x=0, color='red', linestyle='dashed')
ax.set_xlim([-1.5, 0.5])
ax.set_ylim([-0.5, 0.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.grid(True)
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.show()

fig, ax = plt.subplots()
colors = np.linspace(0, 1, len(omega3))
edge_colors = plt.cm.rainbow(colors)
ax.scatter(np.real(omega3), np.imag(omega3), c=colors, cmap='rainbow', marker='o', edgecolors=edge_colors, facecolors='none')
#unit_circle = plt.Circle((0, 0), 1, color='green', fill=False, linestyle='dashed')
#ax.add_artist(unit_circle)
ax.set_aspect('equal', adjustable='datalim')
ax.axvline(x=0, color='red', linestyle='dashed')
ax.set_xlim([-1.5, 0.5])
ax.set_ylim([-0.5, 0.5])
plt.xlabel('Real')
plt.ylabel('Imaginary')
#plt.grid(True)
#plt.title('Eigenvalues on the Unit Circle (Positive Imaginary Part)')
plt.show()

external_variable_1 = PCf

# Code block to measure execution time and RAM requirements
code_block = """
# Access the external variables or dependencies here
print(external_variable_1)

Z = PCf

# Perform DMD
pdmd = DMD(svd_rank=6)
pdmd.fit(Z)

# Access DMD modes and dynamics
pmodes = pdmd.modes.T
pdynamics = pdmd.dynamics

# Visualize DMD modes and dynamics
plt.figure(figsize=(12, 4))

# Plot DMD modes
plt.subplot(1, 2, 1)
for mode in pmodes:
    plt.plot(mode)
plt.title('DMD Modes')

# Plot DMD dynamics
plt.subplot(1, 2, 2)
for dynamic in pdynamics:
    plt.plot(dynamic)
plt.title('DMD Dynamics')

plt.tight_layout()
plt.show()
"""

execution_times = []
memory_usage = []

# Execute the code block 10 times and measure the execution time and RAM requirements
for _ in range(100):
    process = psutil.Process()
    process_memory_before = process.memory_info().rss

    # Create a setup statement to define the local namespace with the external variables
    setup_statement = f"from __main__ import external_variable_1"

    # Measure the execution time
    execution_time = timeit.timeit(stmt=code_block, setup=setup_statement, globals=globals(), number=1)

    # Measure the memory usage
    process_memory_after = process.memory_info().rss
    memory_usage.append(process_memory_after - process_memory_before)

    # Store the execution time
    execution_times.append(execution_time)

# Calculate the average execution time and RAM usage
average_execution_time = sum(execution_times) / len(execution_times)
average_memory_usage = sum(memory_usage) / len(memory_usage)

# Print the average execution time and RAM usage
print("Average Execution Time: {:.6f} seconds".format(average_execution_time))
print("Average RAM Usage: {:.2f} bytes".format(average_memory_usage))

external_variable_1 = snapshots_matrix
external_variable_2 = compression_matrix

# Code block to measure execution time and RAM requirements
code_block = """
# Access the external variables or dependencies here
print(external_variable_1)
print(external_variable_2)

cdmd = CDMD(svd_rank=6, compression_matrix=compression_matrix)
cdmd.fit(snapshots_matrix)

plt.figure(figsize=(16, 8))
plt.subplot(1, 2, 1)
plt.plot(cdmd.modes.real)
plt.subplot(1, 2, 2)
plt.plot(cdmd.dynamics.T.real)
plt.show()
"""

execution_times = []
memory_usage = []

# Execute the code block 10 times and measure the execution time and RAM requirements
for _ in range(100):
    process = psutil.Process()
    process_memory_before = process.memory_info().rss

    # Create a setup statement to define the local namespace with the external variables
    setup_statement = f"from __main__ import external_variable_1"

    # Measure the execution time
    execution_time = timeit.timeit(stmt=code_block, setup=setup_statement, globals=globals(), number=1)

    # Measure the memory usage
    process_memory_after = process.memory_info().rss
    memory_usage.append(process_memory_after - process_memory_before)

    # Store the execution time
    execution_times.append(execution_time)

# Calculate the average execution time and RAM usage
average_execution_time = sum(execution_times) / len(execution_times)
average_memory_usage = sum(memory_usage) / len(memory_usage)

# Print the average execution time and RAM usage
print("Average Execution Time: {:.6f} seconds".format(average_execution_time))
print("Average RAM Usage: {:.2f} bytes".format(average_memory_usage))

dim = []

niter = 4
ndims = 10 ** np.arange(2, 2 + niter)
nsnaps = [100] * niter

for nsnap, ndim in zip(nsnaps, ndims):
    snapshots_matrix = create_dataset(ndim, nsnap)[-1].T
    dim.append(snapshots_matrix.shape[0])
    print(snapshots_matrix.shape)

time_dmd = []
time_cdmd = []
time_dmdpca = []
dim = []

niter = 4
ndims = 10 ** np.arange(2, 2 + niter)
nsnaps = [100] * niter
for nsnap, ndim in zip(nsnaps, ndims):
    pca = PCA(0.9999999999999999)
    snapshots_matrix = create_dataset(ndim, nsnap)[-1].T
    dim.append(snapshots_matrix.shape[0])
    random_matrix = np.random.permutation(
        snapshots_matrix.shape[0] * snapshots_matrix.shape[1]
    )
    random_matrix = random_matrix.reshape(
        snapshots_matrix.shape[1], snapshots_matrix.shape[0]
    )

    compression_matrix = random_matrix / np.linalg.norm(random_matrix)

    PC = pca.fit_transform(snapshots_matrix.T.real)

    t0 = time.time()
    DMD(svd_rank=-1, exact=True).fit(snapshots_matrix)
    t1 = time.time()
    time_dmd.append(t1 - t0)

    t0 = time.time()
    CDMD(svd_rank=-1, compression_matrix=compression_matrix).fit(
        snapshots_matrix
    )
    t1 = time.time()
    time_cdmd.append(t1 - t0)

    t0 = time.time()
    DMD(svd_rank=-1, exact=True).fit(PC.T)
    t1 = time.time()
    time_dmdpca.append(t1 - t0)

plt.figure(figsize=(10, 5))
plt.plot(dim, time_dmd, "ro--", label="Standard dmd")
plt.plot(dim, time_cdmd, "bo--", label="Compressed dmd")
plt.plot(dim, time_dmdpca, "ko--", label="Standard dmd with pca")
plt.legend()
plt.ylabel("Seconds")
plt.xlabel("Snapshots dimension")
plt.show()

time_dmd = []
time_cdmd = []
time_dmdpca = []
time_cdmdpca = []
dim = []

niter = 4
ndims = 10 ** np.arange(2, 2 + niter)
nsnaps = [100] * niter
for nsnap, ndim in zip(nsnaps, ndims):
    pca = PCA(0.99)
    snapshots_matrix = create_dataset(ndim, nsnap)[-1].T
    dim.append(snapshots_matrix.shape[0])
    random_matrix = np.random.permutation(
        snapshots_matrix.shape[0] * snapshots_matrix.shape[1]
    )
    random_matrix = random_matrix.reshape(
        snapshots_matrix.shape[1], snapshots_matrix.shape[0]
    )

    compression_matrix = random_matrix / np.linalg.norm(random_matrix)

    PC = pca.fit_transform(snapshots_matrix.real)

    t0 = time.time()
    DMD(svd_rank=-1, exact=True).fit(snapshots_matrix)
    t1 = time.time()
    time_dmd.append(t1 - t0)

    t0 = time.time()
    CDMD(svd_rank=-1, compression_matrix=compression_matrix).fit(
        snapshots_matrix
    )
    t1 = time.time()
    time_cdmd.append(t1 - t0)

    t0 = time.time()
    DMD(svd_rank=-1, exact=True).fit(PC)
    t1 = time.time()
    time_dmdpca.append(t1 - t0)

    t0 = time.time()
    CDMD(svd_rank=-1, compression_matrix=compression_matrix).fit(
        PC
    )
    t1 = time.time()
    time_cdmdpca.append(t1 - t0)

plt.figure(figsize=(10, 5))
#plt.plot(dim, time_dmd, "ro--", label="exact dmd")
#plt.plot(dim, time_cdmd, "bo--", label="compressed dmd")
plt.plot(dim, time_dmdpca, "go--", label="exact dmd with pca")
plt.plot(dim, time_cdmdpca, "ko--", label="compressed dmd with pca")
plt.legend()
plt.ylabel("Seconds")
plt.xlabel("Snapshots dimension")
plt.show()

time_dmd = []
time_cdmd = []
time_cdmdpca = []
dim = []

niter = 4
ndims = 10 ** np.arange(2, 2 + niter)
nsnaps = [100] * niter
for nsnap, ndim in zip(nsnaps, ndims):
    pca = PCA(0.9999)
    snapshots_matrix = create_dataset(ndim, nsnap)[-1].T
    dim.append(snapshots_matrix.shape[0])
    random_matrix = np.random.permutation(
        snapshots_matrix.shape[0] * snapshots_matrix.shape[1]
    )
    random_matrix = random_matrix.reshape(
        snapshots_matrix.shape[1], snapshots_matrix.shape[0]
    )

    compression_matrix = random_matrix / np.linalg.norm(random_matrix)

    PC1 = pca.fit_transform(snapshots_matrix.real)
    PC2 = pca.fit_transform(snapshots_matrix.imag)
    pc2 = pd.DataFrame(PC2)
    pc1 = pd.DataFrame(PC1)
    pc3 = pc1.T.append(pc2.T)
    PC3 = np.array(pc3)

    t0 = time.time()
    DMD(svd_rank=-1, exact=True).fit(snapshots_matrix)
    t1 = time.time()
    time_dmd.append(t1 - t0)

    t0 = time.time()
    CDMD(svd_rank=-1, compression_matrix=compression_matrix).fit(
        snapshots_matrix
    )
    t1 = time.time()
    time_cdmd.append(t1 - t0)

    t0 = time.time()
    CDMD(svd_rank=-1, compression_matrix=compression_matrix).fit(
        PC3.T
    )
    t1 = time.time()
    time_cdmdpca.append(t1 - t0)

plt.figure(figsize=(10, 5))
plt.plot(dim, time_dmd, "ro--", label="Standard dmd")
plt.plot(dim, time_cdmd, "bo--", label="Compressed dmd")
plt.plot(dim, time_cdmdpca, "ko--", label="Compressed dmd with pca")
plt.legend()
plt.ylabel("Seconds")
plt.xlabel("Snapshots dimension")
plt.show()

dmd_rec_real = pdmd.reconstructed_data[0:3]
dmd_rec_imag = pdmd.reconstructed_data[3:]

x_recon_real = pca_r.inverse_transform(dmd_rec_real.T)
x_recon_imag = pca_i.inverse_transform(dmd_rec_imag.T)

X_recon = x_recon_real + 1j * x_recon_imag

plt.figure(figsize=(12, 4))
plt.subplot(1, 4, 1)
plt.title("Original snapshots")
plt.pcolor(xgrid, tgrid, X.real)
plt.subplot(1, 4, 2)
plt.title("Reconstructed with DMD")
plt.pcolor(xgrid, tgrid, dmdo.reconstructed_data.real.T)
plt.subplot(1, 4, 3)
plt.title("Reconstructed with CDMD")
plt.pcolor(xgrid, tgrid, cdmd_2.reconstructed_data.real.T)
plt.subplot(1, 4, 4)
plt.title("Reconstructed with PCA-DMD")
plt.pcolor(xgrid, tgrid, X_recon.real)

diff_dmd = X.real - dmdo.reconstructed_data.real.T
diff_cdmd = X.real - cdmd_2.reconstructed_data.real.T
diff_pcadmd = X.real - X_recon.real

plt.figure(figsize=(12, 4))
plt.subplot(1, 4, 1)
#plt.title("Original snapshots")
plt.pcolor(xgrid, tgrid, X.real)
fig = plt.colorbar()
plt.subplot(1, 4, 2)
#plt.title("Reconstructed with DMD")
plt.pcolor(xgrid, tgrid, diff_dmd.real)
fig = plt.colorbar()
plt.subplot(1, 4, 3)
#plt.title("Reconstructed with CDMD")
plt.pcolor(xgrid, tgrid, diff_cdmd.real)
fig = plt.colorbar()
plt.subplot(1, 4, 4)
#plt.title("Reconstructed with PCA-DMD")
plt.pcolor(xgrid, tgrid, diff_pcadmd.real)
fig = plt.colorbar()

import sys

X_size_bytes = sys.getsizeof(X)

# Convert bytes to megabytes
X_size_kilobytes = X_size_bytes / 1024

print(f"Array size: {X_size_kilobytes:.2f} KB")

PC_size_bytes = sys.getsizeof(PCf)

# Convert bytes to megabytes
PC_size_kilobytes = PC_size_bytes / 1024

print(f"Array size: {PC_size_kilobytes:.2f} KB")

DMD_size_bytes = sys.getsizeof(pdmd.reconstructed_data)

# Convert bytes to megabytes
DMD_size_kilobytes = DMD_size_bytes / 1024

print(f"Array size: {DMD_size_kilobytes:.2f} KB")

cdmd_2.growth_rate